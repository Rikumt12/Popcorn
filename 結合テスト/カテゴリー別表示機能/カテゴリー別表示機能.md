# 機能: カテゴリ別表示

## テスト対象API

- `GET /api/products?category=キッチン用品`（カテゴリ名による商品一覧取得）

## テストデータ準備方針

- 各テスト実行前に、データベースを初期化し、必要なカテゴリおよび商品データを挿入します。
- テスト用カテゴリ: `Category(ID, Name)`
- テスト用商品データは `Product(ID, Name, Price, Desc, Stock, ImageUrl, IsRecommended, Category)` の形式で記述します。

## テストシナリオ

### No. 5-1

- テストケース名: カテゴリ別表示（正常系 - 「キッチン用品」カテゴリの商品が表示される）
- 前提条件:
  1. データベースに以下のカテゴリが存在する。
     - `Category(1, "キッチン用品")`
  2. データベースに以下の5件の商品が存在する。
     - `Product(1, "ステンレスタンブラー","保温・保冷機能に優れたシンプルなデザインのステンレスタンブラー。容量350ml",2800,30, "/images/tumbler.png", false, kitchen)`
     - `Product(2, "木製コースター（4枚セット）", "天然木を使用したシンプルなデザインのコースター。4枚セット。",1800,50,"/images/wooden-coaster.png",false, kitchen)`
     -  `Product(3, "カトラリー", "天然素材で作られたラタン調のカトラリー。４つの仕切りで使いやすい構造。", 1600, 35, "/images/katorari.png", true, kitchen)`  
     - `Product(4, "エプロン", "やわらかなコットン生地と落ち着いたカラーが魅力のシンプルなエプロン。", 2000, 35, "/images/epuronn.png", true, kitchen)`  
     - `Product(5, "ガラス保存容器セット", "電子レンジ・食洗機対応のガラス製保存容器。3サイズセット。", 1300, 20, "/images/glass-container.png", false, kitchen)`
  3. 他のカテゴリに属する商品（例: `"リビングインテリア"`）は存在してもよいが、このテストの検証対象外。
- 手順:
  1. HTTP GETリクエストを以下のエンドポイントに送信する。  
     `GET http://localhost:8080/api/products?category=キッチン用品`
- 入力データ: なし（GETリクエスト）
- 期待結果:
  1. HTTPステータスコードが `200 OK` であること。
  2. レスポンスボディがJSON形式であること。
  3. 返却されるJSON配列の要素数が 5件であること。
  4. 各要素が `ProductListItem` DTO形式（`productId`, `name`, `price`, `imageUrl`）で構成されていること。
  5. 以下の内容を含む5つの商品が返却されていること（順不同でも可）:
     - `{"productId": 1, "name": "ステンレスタンブラー", "price": 2800, "imageUrl": "/images/tumbler.png"}`
     - `{"productId": 2, "name": "木製コースター（4枚セット）", "price": 1800, "imageUrl": "/images/wooden-coaster.png"}`
     - `{"productId": 3, "name": "カトラリー", "price": 1600, "imageUrl": "/images/katorari.png"}`
     - `{"productId": 4, "name": "エプロン", "price": 2000, "imageUrl": "/images/epuronn.png"}`
     - `{"productId": 5, "name": "ガラス保存容器セット", "price": 1300, "imageUrl": "/images/glass-container.png"}`

### No. 5-2

- テストケース名: 全カテゴリ表示（正常系 - 全商品が返却される）
- 前提条件:
  1. データベースに商品が26件登録されている
- 手順:
  1. HTTP GETリクエストを `/api/products` エンドポイントに送信する。  
     `GET http://localhost:8080/api/products`
- 入力データ: なし（GETリクエスト）
- 期待結果:
  1. HTTPステータスコードが `200 OK` であること。
  2. レスポンスボディが JSON 配列であること。
  3. 配列の要素数が 26件であること。
  4. 各要素が `ProductListItem` DTO形式（`productId`, `name`, `price`, `imageUrl`）で構成されていること。
 
### No. 5-3

- テストケース名: 存在しないカテゴリ名（異常系 - 空リスト返却）
- 前提条件:
  1. データベースに「おもちゃ」というカテゴリは存在しない。
  2. 他のカテゴリ（例：「キッチン用品」）の商品が存在していてもよいが、本ケースには影響しない。
- 手順:
  1. HTTP GETリクエストを `/api/products?category=おもちゃ` に送信する。
     GET http://localhost:8080/api/products?category=おもちゃ
- 入力データ: クエリパラメータ category=おもちゃ
- 期待結果:
  1. HTTPステータスコードが `200 OK` であること。
  2. レスポンスボディが JSON 形式であること。
  3. JSON配列が空（`[]`）であること。

### No. 5-4
### No. 5-5

- テストケース名: カテゴリ別表示（異常系 - 数字や記号のカテゴリ名）
- 前提条件:
  1. データベース内に "123@#%" という名前のカテゴリは存在しない。
  2. 他のカテゴリ（例: "キッチン用品"、"リビング"など）は存在していても構わない。
  3. ProductService.findProductsByCategoryName(...) がカテゴリ名で商品を検索する仕組みになっている。
- 手順:
  1. HTTP GETリクエストを以下のエンドポイントに送信する：
     GET http://localhost:8080/api/products?category=123@#%
- 入力データ: カテゴリ名 = 123@#%
- 期待結果:
  1. HTTPステータスコードが`200 OK`であること。
  2. レスポンスボディがJSON形式で、空の配列`[]`を返却すること。
  3. サーバー側で例外やエラーが発生しないこと（正常応答とみなされる）。

### No. 5-6

- テストケース名: カテゴリ別表示（異常系 - DB接続エラー）
- 前提条件:
  1. アプリケーションが起動しており、エンドポイント /api/products?category=キッチン用品 が有効である。
  2. テスト時に DB接続を遮断またはDBを停止しておく（例: データベースをシャットダウン、DB接続先を不正に設定など）。
  3. サーバー側で ProductService → CategoryRepository などの呼び出し時に例外が発生する状況が作られている。
- 手順:
  1. HTTP GETリクエストを以下のエンドポイントに送信する：
     GET http://localhost:8080/api/products?category=キッチン用品
  2. DB接続が不能な状態で、リクエストを実行。
- 入力データ: なし（GETリクエスト）
- 期待結果:
  1. HTTPステータスコードが`500 Internal Server Error`であること。
  2. サーバー側で発生した例外（例: DataAccessException, SQLNonTransientConnectionException 等）が、適切に補足されること。
  3. エラーレスポンスの本文に、以下のいずれかを含むJSON形式のエラーメッセージが返される（GlobalExceptionHandler による）：{"error": "Internal Server Error","message": "データベースへの接続に失敗しました","status": 500 }

### No. 5-7

- テストケース: （異常系 - APIタイムアウト）
- 前提条件:
  1. GET /api/products?category=キッチン用品 のリクエストがサーバーで意図的に遅延するよう設定されている（例: モックサーバーでレスポンス遅延、またはネットワークシミュレーター等で遅延挿入）。
  2. フロントエンドのHTTPクライアント側でタイムアウトの設定（例: 5秒）が有効になっている。
- 手順:
  1. HTTP GETリクエストを以下のエンドポイントに送信する:
     GET http://localhost:8080/api/products?category=キッチン用品
  2. サーバー側で意図的にレスポンスを10秒以上遅延させる（フロントのタイムアウト設定を超えるようにする）。
- 入力データ: なし（GETリクエスト）
- 期待結果:
  1. フロントエンド側でタイムアウトが検出される。
  2. 「通信に失敗しました」「タイムアウトしました」などのエラーメッセージが表示されること。
  3. ローディングインジケーターが停止し、UIがエラー状態の表示に切り替わること。
  4. 開発者コンソール（例: ブラウザのDevTools）では、タイムアウトエラーが確認できる（例: net::ERR_TIMED_OUT や TimeoutError）。